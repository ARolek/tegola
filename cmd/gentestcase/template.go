package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"path/filepath"
	"text/template"
)

var dataTmpl = template.Must(template.New("Data").Parse(`
// generated by gentestcase {{.Command}};
//    change the expected values to the appropriate values for the test case.
// Test case Generated by {{.User}} on {{.Date}}
// GID:{{.GID}}
//
package {{.PackageName}}

{{- if .UserComment }}
/*
{{.UserComment}}
*/
{{- end}}

var geom{{.DataSha1}} = []byte{
{{.Bytes}}
}
`))

var geomTmpl = template.Must(template.New("Geo").Parse(`
// generated by gentestcase {{.Command}};
//    change the expected values to the appropriate values for the test case.
// Test case Generated by {{.User}} on {{.Date}}
// GID:{{.GID}}
//
package {{.PackageName}}

import "github.com/terranodo/tegola/basic"


{{- if .UserComment }}
/*
{{.UserComment}}
*/
{{- end}}

var {{.GeomVar}}{{.DataSha1}} = {{.Geom}}

`))

var generatedTmpl = template.Must(template.New("generated").Parse(`
// generated by gentestcase {{.Command}};
//    change the expected values to the appropriate values for the test case.
// Test case Generated by {{.User}} on {{.Date}}
// Coordinate: X:{{.X}} Y:{{.Y}} Z:{{.Z}} GID:{{.GID}}
//
package {{.PackageName}}
import (
	"fmt"
	"os"
	"testing"

	"github.com/terranodo/tegola"
	"github.com/terranodo/tegola/basic"
	"github.com/terranodo/tegola/maths/validate"
	"github.com/terranodo/tegola/draw/svg"
	"github.com/terranodo/tegola/mvt"
	"github.com/terranodo/tegola/wkb"
)

{{- if .UserComment }}
/*
{{.UserComment}}
*/
{{- end}}


func Geom{{.Suffix}}FromRaw(t *testing.T) (geom tegola.Geometry, err error){
	srid := {{.LayerSRID}}
	tile := tegola.Tile{
		X : {{.X}},
		Y : {{.Y}},
		Z : {{.Z}},
	}
	cursor := mvt.NewCursor(tile.BoundingBox(), {{.LayerExtent}})
	geom, err = wkb.DecodeBytes(geom{{.DataSha1}})
	if err != nil {
		t.Fatalf("Failed to convert raw bytes. failed.: %v.",err)
		return geom, err
	}

	if srid != tegola.WebMercator {
		// We need to convert our points to Webmercator.
		g, err := basic.ToWebMercator({{.LayerSRID}}, geom)
		if err != nil {
			t.Fatal("Was unable to transform geometry to webmercator from SRID ({{.LayerSRID}}) for layer ({{.LayerName}})")
			return nil, err
		}
		geom = g.Geometry
	}
	g := cursor.ScaleGeo(geom)
	vg, err := validate.CleanGeometry(g)
	if err != nil {
		t.Fatalf("CleanGeometry failed.: %v.",err)
	}
	return vg, err
}

func Test{{.Suffix}}(t *testing.T){


	suffix := "{{.Suffix}}"
	// srid := {{.LayerSRID}}
	tile := tegola.Tile{
		X : {{.X}},
		Y : {{.Y}},
		Z : {{.Z}},
	}
	t.Logf("Starting test: %v.",suffix)
	cursor := mvt.NewCursor(tile.BoundingBox(), {{.LayerExtent}})
	var geom tegola.Geometry = {{.GeomVar}}{{.DataSha1}}
	var err error


	//log.Println("Tolerence:", tile.ZEpislon())
	//sg := mvt.SimplifyGeometry(geom, tile.ZEpislon())
	vg, err := validate.CleanGeometry(geom)
	if err != nil {
		panic(err)
	}
	cg, gerr := cursor.ClipGeo(vg)

	mm := svg.MinMax{0, 0, 8096, 8096}
	mm.ExpandBy(100)
	canvas := &svg.Canvas{
		Board:  mm,
		Region: svg.MinMax{0, 0, 4096, 4096},
	}

	filename := fmt.Sprintf("geo_%v.svg", suffix)
	file, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	canvas.Init(file, 1440, 900, false)
	canvas.DrawGeometry(geom, "simplified", "fill:green;opacity:0.5", "fill:black;opacity:0.5", false)
	canvas.DrawGeometry(vg, "cleaned", "fill:green;opacity:0.5", "fill:blue;opacity:0.5", false)
	canvas.DrawRegion(false)
	canvas.DrawGeometry(cg, "clipped", "fill:green;opacity:0.5", "fill:green;opacity:0.5", false)
	canvas.End()


	if gerr != expectedErr{{.Suffix}} {
		t.Fatalf("Did not get expected error: %v. Got: %v",expectedErr{{.Suffix}},err)
	}
	if expectedErr{{.Suffix}} != nil {
		// Don't worry about expected geom as there isn't one.
		return
	}
	if expected{{.Suffix}} == nil && cg == nil {
		// We are expecting nil.
		return
	}
	if !tegola.IsGeometryEqual(expected{{.Suffix}},cg) {
		t.Fatalf("Did not get expected Geometry: %v\n\tgot:%v",expected{{.Suffix}},cg)
	}

}

func init(){
	// Please fill out expected tegola.Geometry
	// expected{{.Suffix}} = «PLACEHOLDER»
	// If we are expecting an error:
	// expectedErr{{.Suffix}} = fmt.Errorf("Expected error")
}

var expectedErr{{.Suffix}} error
var expected{{.Suffix}} tegola.Geometry

`))

type testcase struct {
	User        string
	Date        string
	PackageName string
	UserComment string
	Command     string
	DataSha1    string
	Suffix      string
	LayerExtent int
	LayerName   string
	LayerSRID   int
	LayerSQL    string
	Bytes       string
	Geom        string
	GeomVar     string
	X           int
	Y           int
	Z           int
	GID         uint64
}

func gensrc(tmpl *template.Template, tc *testcase) (src []byte, err error) {

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tc); err != nil {
		log.Fatalf("generating code: %v", err)
		return src, err
	}

	src, err = format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = buf.Bytes()
	}
	return src, err
}

func writeFile(dir, file string, src []byte) error {

	outputPath := filepath.Join(dir, file)
	log.Println("Writing out file:", outputPath)
	if err := ioutil.WriteFile(outputPath, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
		return err
	}
	return nil
}
